"""
날짜 : 2021.08.10
학습 : SWEA PI_list_01
제목 : 4835. [파이썬 S/W 문제해결 기본] 1일차 - 구간합
문제 :
N개의 정수가 들어있는 배열에서 이웃한 M개의 합을 계산하는 것은 디지털 필터링의 기초연산이다.
M개의 합이 가장 큰 경우와 가장 작은 경우의 차이를 출력하는 프로그램을 작성하시오.
다음은 N=5, M=3이고 5개의 숫자 1 2 3 4 5가 배열 v에 들어있는 경우이다.

v 12345

v \123\45
이웃한 M개의 합이 가장 작은 경우 1 + 2 + 3 = 6
v 12\345\
이웃한 M개의 합이 가장 큰 경우 3 + 4 + 5 = 12
답은 12와 6의 차인 6을 출력한다.

[입력]
첫 줄에 테스트 케이스 개수 T가 주어진다.  ( 1 ≤ T ≤ 50 )
다음 줄부터 테스트케이스의 첫 줄에 정수의 개수 N과 구간의 개수 M 주어진다. ( 10 ≤ N ≤ 100,  2 ≤ M ＜ N )
다음 줄에 N개의 정수 ai가 주어진다. ( 1 ≤ a ≤ 10000 )
3
10 3
1 2 3 4 5 6 7 8 9 10
10 5
6262 6004 1801 7660 7919 1280 525 9798 5134 1821
20 19
3266 9419 3087 9001 9321 1341 7379 6236 5795 8910 2990 2152 2249 4059 1394

[출력]
각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.
#1 21
#2 11088
#3 1090
"""
'''
전체 N개에서 M개의 구간합을 너무 더하고 가장 큰값, 가장 작은값의 차 구하기
버블 정렬 연습
'''


def bubble(nums):  # 버블 정렬
    # nums 인덱스 가지고오기 한바퀴 돌면 맨 뒤에꺼 필요없으니..뒤부터, 맨앞 인덱스(0)는 필요없음
    for i in range(len(nums) - 1, 0, -1):
        for j in range(0, i):  # 이제는 앞에서부터 처음 가지고 오는 인덱스 처음(0, 9)
            if nums[j] > nums[j + 1]:  # 앞에 숫자가 크면 뒤랑 바꾸기
                nums[j], nums[j + 1] = nums[j + 1], nums[j]


T = int(input())

for tc in range(1, T + 1):
    N, M = map(int, input().split())  # N = 정수 갯수 M = 구간 갯수
    nums = list(map(int, input().split()))

    tot_nums = []
    for i in range(0, N - M + 1):
        cnt = 0
        for j in range(M):
            cnt += nums[i + j]
        tot_nums += [cnt]

    bubble(tot_nums)

    result = tot_nums[-1] - tot_nums[0]

    print('#{} {}'.format(tc, result))
