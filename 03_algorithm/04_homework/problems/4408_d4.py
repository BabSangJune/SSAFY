"""
날짜 : 2021.08.15
학습 : SWEA D4
제목 : 4408 .자기 방으로 돌아가기
문제 :
고등학교 학생들이 학교에서 수련회를 갔다. 수련회에 간 학생들은 친구들과 음주가무를 즐기다가 밤 12시가 되자 조교들의 눈을 피해 자기방으로 돌아가려고 한다.
제 시간에 자기방으로 돌아가지 못한 학생이 한 명이라도 발견되면 큰일나기 때문에 최단 시간에 모든 학생이 자신의 방으로 돌아가려고 한다.
숙소는 긴 복도를 따라 총 400개의 방이 다음과 같이 배열되어 있다.

모든 학생들은 현재 위치에서 자신의 방으로 돌아가려고 하는데, 만약 두 학생이 자기방으로 돌아가면서 지나는 복도의 구간이 겹치면 두 학생은 동시에 돌아갈 수 없다.
예를 들어 (방1 -> 4) 와 (방3 -> 6) 은 복도 구간이 겹치므로 한 사람은 기다렸다가 다음 차례에 이동해야 한다. 이동하는 데에는 거리에 관계없이 단위 시간이 걸린다고 하자.
각 학생들의 현재 방 위치와 돌아가야 할 방의 위치의 목록이 주어질 때, 최소 몇 단위시간만에 모든 학생들이 이동할 수 있는지를 구하시오.

[입력]
입력은 T(≤10)개의 테스트 케이스로 되어 있다. 각 테스트 케이스의 첫 줄에는 돌아가야 할 학생들의 수 N이 주어진다.
다음 N 줄에는 각 학생의 현재 방 번호(≤400)와 돌아가야 할 방의 번호(≤400)가 주어진다. 주어지는 2N개의 방 번호 중 중복되는 것은 없다.
3
4
10 20
30 40
50 60
70 80
2
1 3
2 200
3
10 100
20 80
30 50
[출력]
테스트 케이스 T에 대한 결과는 “#T ”을 찍고, 각 테스트 케이스마다 필요한 시간을 한 줄에 하나씩 출력한다.
#1 1
#2 2
#3 3
"""

T = int(input()) #tc 갯수

for tc in range(1, T+1):
    N = int(input()) #노선 갯수
    empty_lst = [[0] * 5001 for _ in range(N)] #5천개의 정류장 노선 수 만큼

    for n in range(N):
        route_start, route_end = map(int, input().split()) # n번 노선 정류장 처음과 끝

        for i in range(route_start, route_end+1):
            empty_lst[n][i] += 1 #n번 노선 다니는 정류장을 1로 바꾸기

    cp_stop = int(input()) #비교 할 노선 갯수
    result = [] #최종 값 저장
    # cnt_stop = [0] * 5001  # n번 노선이 cp_stop을 지나면 카운트 할 리스트 이거 여기있으면 초기화 안되서 중복 값이 들어가면 지랄남

    for stop in range(cp_stop): #cp_stop 만큼 no_stop input 받아오기
        cnt_stop = [0] * 5001  # n번 노선이 cp_stop을 지나면 카운트 할 리스트
        no_stop = int(input()) #비교 할 노선 번호

        for i in range(N): #노선 번호 가지고 오기
            if empty_lst[i][no_stop] == 1: #i번 노선에 no_stop이 지나가면
                cnt_stop[no_stop] += 1 # cnt_stop에 카운트

        result += [cnt_stop[no_stop]] #12개 중 5개 맞음.. 왜 ???

    # for i in range(5001): #0 제외 하고 result에 넣기 #0개 맞음 no_stop이 노선 안에 안지나가면 0 출력 해야함
    #     if cnt_stop[i] != 0:
    #         result += [cnt_stop[i]]

    print('#{}'.format(tc), end=' ')
    print(*result)


